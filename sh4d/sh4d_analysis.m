function [DNLK, im,A] = sh4d_analysis(I,N_max,L_max)
% Series expansion of the 4-D image (3D volume + intensity) in 4D spherical
% harmonic functions. Basis functions are generated by sh4d_basis_gen.
% Returns the coefficients from which the complete image may be
% reconstructed, in a low-pass filtered sense.
% Note on memory requiremens: a 64^3 column requires 1MB memory,
% To calculate the memory requirements for the whole basis matrix do this:
% (xdim)x (ydim)x(zdim)x 4 x (no.of basis vetors)
% where number of basis vectors is :
% [N, L, K ] = sh4d_indices_gen(Nmax,Lmax); disp(length(L))
% for 16 GB total RAM a basis of 15 000 should be maximum (will try this).
% Nmax = 15, Lmax = 20 seems a good choice, but always keep s < 15000.

verbose = 1;
dim = size(I,1);
tau = size(I, 1);
pad_vec = ([dim dim dim]);
I = padarray(I,pad_vec);

% [av_i, av_j, av_k] = center_of_mass(I);av_i = round(av_i);av_j = round(av_j);av_k = round(av_k);
av_i = round(size(I,1)/2);av_j = round(size(I,2)/2);av_k = round(size(I,3)/2);

%% generate theta, phi and r from the image
[ix iy iz] = ind2sub(size(I),1:length(I(:)));
x = ix -av_i;y = iy-av_j;z = iz-av_k;  % move coordinate system to center of mass
[t p r] = kk_cart2sph(x,y,z);


%% generate the required basis vectors
%%% check whether we have the matrix A or svd components stored on disk
[N, L, K ] = sh4d_indices_gen(N_max,L_max);
% if length(L)<s, s = length(L);end;
s = length(L);
str = sprintf('SVD_gdim%d_N%d_L%d_%d_tau_%d.mat',size(I,1),N_max, L_max,length(L), tau);
if exist(str)==2,
    load(str);
    if verbose, disp('Loading precalculated basis matrix decomposition');end;
else
    warning off MATLAB:divideByZero;
    %[N, L, K ] = sh4d_indices_gen(N_max,L_max);
    m = length(L); %% number of functions in expansion
    disp(m);
    n = length(r(:)); %% number of data points

    %%% Calcualte the basis matrix using one processor
    %%% uncomment below for the single processor usage
        A  = zeros(n, m, 'single');
        h = waitbar(0,'Generating basis matrix ....');
        for S = 1:m,
            A(:, S) = sh4d_basis_gen(N(S),L(S),K(S),p(:)',t(:)',r(:)', tau)';
            waitbar(S/m);
        end
        close(h); drawnow;
    disp('Solving LS system....');
    [U, S, V] = svd(A'*A, 0);invS = 1./(S);invS(invS==inf) = 0;
    save(str,'U', 'V', 'invS', 'A', 'N', 'L', 'K', 'tau');
end;

%%% use the svd
D= (V*invS) * (U'*(A'*I(:)));
DNLK.D = D;
DNLK.N = N;
DNLK.L = L;
DNLK.K = K;
DNLK.tau = tau;

disp('Done !');
%% Plot the volume based on the DNLKs only
f = A*D;
indx = sub2ind(size(I),ix, iy, iz);
im = I;
im(indx) = f;
%% crop the arrays
if dim,
    im = im(pad_vec(1):end-pad_vec(1)-1, pad_vec(2):end-pad_vec(2)-1, pad_vec(3):end-pad_vec(3)-1);
    I = I(pad_vec(1):end-pad_vec(1)-1, pad_vec(2):end-pad_vec(2)-1, pad_vec(3):end-pad_vec(3)-1);
    %% display
end
% im = mat2gray(im);
% a = im(:)\I(:);
% kk_montage([[mat2gray(I) (im)] mat2gray(imsubtract(I,im))]);
% impixelinfo;
kk_montage([[mat2gray(I) (im)]]);
str = sprintf('Results_SH4D_N%dL%d.mat',N_max, L_max);

save(str,'I', 'DNLK', 'im');
% figure;plot(D.^2);


%%% Calculate the maxima (hopefully centers of ellipsoids)
%%% The idea is to evaluate the zeros of the second derivatives




















