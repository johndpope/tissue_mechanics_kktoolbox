function [DNLK f] = sh4d_analysis_sirf_dist(I, N_max, L_max)
% SIRF: Simple Iterative Residual Fitting
% Series expansion of the 4-D image (3D volume + intensity) in 4D spherical
% harmonic functions. Basis functions are generated by sh4d_basis_gen.
% Returns the coefficients from which the complete image may be
% reconstructed, in a low-pass filtered sense.

clc;verbose = 1;if verbose, tic;end
size_limit = 3e8;        % bytes/processor/task


tau = size(I, 1);
dim = size(I, 1)/2;
pad_vec = ([dim dim dim]);
I = padarray(I,pad_vec);

[av_i, av_j, av_k] = center_of_mass(I);
av_i = round(av_i);av_j = round(av_j);av_k = round(av_k);
%% generate theta, phi and r from the image
[ix iy iz] = ind2sub(size(I),1:length(I(:)));
x = ix -av_i;y = iy-av_j;z = iz-av_k;  % move coordinate system to center of mass
[t p r] = kk_cart2sph(x,y,z);
indx = sub2ind(size(I),ix, iy, iz);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Generate a set of input cell arrays with assigned basis vectors that
%% correspond to (almost) equal and manageable chuncks for each processor
%% These inputs are then assigned to tasks as follows:
%% 1 - every 4 tasks are executed in a job.
%% 2-  The basis matrix is assembled and solved.
%% 3-  the residual vector is calculated
%% 4-  repeat.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% task input generation
[N, L, K ] = sh4d_indices_gen(N_max,L_max); % automatic generation of complete basis vector set

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%% Exclude basis vectors for N here
N_ex = [];  % L values to be excluded
for ix = 1:length(N_ex),
    L(N==N_ex(ix)) = [];K(N==N_ex(ix)) = [];N(N==N_ex(ix))=[];
end
%%%%%%% Exclude basis vectors for L here
L_ex = [];  % L values to be excluded
for ix = 1:length(L_ex),
    N(L==L_ex(ix)) = [];K(L==L_ex(ix)) = [];L(L==L_ex(ix))=[];
end
%%%%%%% Exclude basis vectors for K here
K_ex = [];%[[-max(L):-1] [1:5]];  % L values to be excluded
for ix = 1:length(K_ex),
    N(K==K_ex(ix)) = [];L(K==K_ex(ix)) = [];K(K==K_ex(ix))=[];
end

% load basis.mat% file with predefined basis vectors

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%

if verbose,disp(['Ideal basis size: ' num2str(length(N))]);end
basis_size = length(L);%-mod(length(L),4);
N = (N(1:basis_size));
L = (L(1:basis_size));
K = (K(1:basis_size));
if verbose,disp(['Actual basis size: ' num2str(length(N))]);end

M = length(I(:));
s = round(size_limit /M/4); % number of basis vectors that fit into one task with this I and size_limit   %       totalsize = length(I)*s * 4;    % 4 bytes for single precision
remain = length(N); % start out with all basis vectors remaining
counter = 0;
pos  = 1;
inp1 = {};
inp_vec = {};   % cell array of cell arrays of inputs
while remain>0,
    counter = counter +1;
    %% distribute these parts of the basis matrix as tasks
    if length(N(pos:end))>=s
        vec = pos : pos+s-1;
        inp1{1} = N(vec);inp1{2} = L(vec);inp1{3} = K(vec);inp1{4} = p(:)';inp1{5} = t(:)';inp1{6} = r(:)';inp1{7} = tau;
        pos = pos + s;
        remain = remain-s;
    else
        vec = pos : pos+length(N(pos:end))-1;
        inp1{1} = N(vec);inp1{2} = L(vec);inp1{3} = K(vec);inp1{4} = p(:)';inp1{5} = t(:)';inp1{6} = r(:)';inp1{7} = tau;
        pos = pos + s;
        remain = remain-length(vec);
    end
    inp_vec{counter} = inp1;
end

if verbose,
str = sprintf(...
    '# basis vectors/task for basis matrix of singles: %d \n Total # of tasks: %d \n Dimension of basis matrix chunck:  %d x %d = %d',...
    s,size(inp_vec,2),M, s, s*M); disp(str);
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
N = [];L = [];K = [];
for ix = 1:size(inp_vec,2),
    inp = inp_vec{ix};
    N = [N; inp{1}];L = [L; inp{2}];K = [K; inp{3}];
    disp(['Task ' num2str(ix) ' : ' num2str(length(inp{1})) ' basis vectors']);
end
sched = findResource('scheduler', 'type', 'local');
remaining_tasks = length(inp_vec);
pos = 0;
counter = 0;
residual = I(:);
res_vec = [];
f = zeros(length(I(:)),1,'single');
D_vec = [];
DNLK.N = N;
DNLK.L = L;
DNLK.K = K;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% START SIRF ITERATIONS %%%%%%%%%%%%%%%%%%%%%%
Nproc = 4;  % number of processors to use
while remaining_tasks>0
    counter = counter + 1;
    if verbose,disp(['# of remaining tasks ' num2str(remaining_tasks)]);end;
    j = createJob(sched);
    if remaining_tasks>=Nproc,
        for ix = 1:Nproc,
            pos = pos + 1;
            warning off;createTask(j, @sh4d_basis_gen_vec, 1, inp_vec{pos});warning on;
        end
        remaining_tasks = remaining_tasks-Nproc;
    else
        for ix = 1:remaining_tasks,
            pos = pos + 1;
            warning off;createTask(j, @sh4d_basis_gen_vec, 1, inp_vec{pos});warning on;
        end
        remaining_tasks = 0;
    end
    if verbose, disp(['Submitting task batch '  num2str(counter) '   using ' num2str(Nproc) ' tasks/batch']);end
    submit(j);waitForState(j, 'finished'); % Execute 4 consecutive tasks untill all tasks are done.
    if verbose, disp('......... finished!');end
    %%%% display errors if any
    errmsgs = get(j.Tasks, {'ErrorMessage'});
    nonempty = ~cellfun(@isempty, errmsgs);
    celldisp(errmsgs(nonempty));
    %%%
    results = getAllOutputArguments(j)';
    A = cell2mat(results);
    clear results;destroy(j);
    if verbose, disp('basis matrix size');disp(size(A));end;
% %     if ~any(size(A)~=[length(p) 4*s])==0,
% %         error('Basis matrix dimensions inconsistency');
% %     end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%% Solve the system
    disp('Solving LS system....');
        warning off;[U, S, V] = svd(A'*A, 0); invS = 1./(S);invS(invS==inf) = 0;warning on;
        D = (V*invS) * (U'*(A'*residual(:)));
    %warning off;    D = A\residual(:);warning on;
    if verbose, disp('..... Done !');end;
    r_vec = A*D(:); r_vec = r_vec(:);
    f = f + r_vec;
    residual = residual-r_vec;
    res_vec = [res_vec (norm(I(:)-f(:)))];
    D_vec = [D_vec; D(:)];
    if verbose, 
        warning off;
%         kk_montage([mat2gray(I) mat2gray(reshape(f,size(I)))]);
        Isyn = reshape(f,size(I));
        Isyn = Isyn(pad_vec(1):end-pad_vec(1), pad_vec(2):end-pad_vec(2), pad_vec(3):end-pad_vec(3));
        Iorig = I(pad_vec(1):end-pad_vec(1), pad_vec(2):end-pad_vec(2), pad_vec(3):end-pad_vec(3));
        %% display
        kk_montage([mat2gray(Iorig) mat2gray(Isyn)]);
        warning on;

        drawnow;
    end
end
DNLK.D =D_vec;
DNLK.method = 'sirf_dist';
DNLK.tau = tau;
DNLK.old = 0;
DNLK.im = f;

f = reshape(f,size(I));
f = f(pad_vec(1):end-pad_vec(1)-1, pad_vec(2):end-pad_vec(2)-1, pad_vec(3):end-pad_vec(3)-1);
I = I(pad_vec(1):end-pad_vec(1)-1, pad_vec(2):end-pad_vec(2)-1, pad_vec(3):end-pad_vec(3)-1);
%% display
kk_montage([mat2gray(I) mat2gray(f)]);
impixelinfo;
% if counter, figure;plot(res_vec);end
save last_dnlk_I_f DNLK I f;
DNLK.im = f;

disp(DNLK);DNLK_show(DNLK);

if verbose, toc;end


