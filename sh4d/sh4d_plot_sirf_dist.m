function [I] = sh4d_plot_sirf_dist(DNLK, dimI)
% SIRF: Simple Iterative Residual Fitting
% Series expansion of the 4-D image (3D volume + intensity) in 4D spherical
% harmonic functions. Basis functions are generated by sh4d_basis_gen.
% Returns the coefficients from which the complete image may be
% reconstructed, in a low-pass filtered sense.
if nargin==1,dimI = 32;end;
verbose = 1;
size_limit = 1e8;        % bytes/processor/task
tau = dimI;%DNLK.tau;
dim = tau/2;
pad_vec = ([dim dim dim]);
I = zeros(dimI, dimI, dimI,'single');
I = padarray(I,pad_vec);

%%%%%%%%%%%%%%%%%%%%%%%%%


% [av_i, av_j, av_k] = center_of_mass(I);
av_i = round(size(I,1)/2);av_j = round(size(I,2)/2);av_k = round(size(I,3)/2);
%% generate theta, phi and r from the image
[ix iy iz] = ind2sub(size(I),1:length(I(:)));
x = ix -av_i;y = iy-av_j;z = iz-av_k;  % move coordinate system to center of mass
[t p r] = kk_cart2sph(x,y,z);
indx = sub2ind(size(I),ix, iy, iz);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Generate a set of input cell arrays with assigned basis vectors that
%% correspond to (almost) equal and manageable chuncks for each processor
%% These inputs are then assigned to tasks as follows:
%% 1 - every 4 tasks are executed in a job.
%% 2-  The basis matrix is assembled.
%% 3-  the improved image is calculated
%% 4-  repeat.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
verbose = 1;
%%% task input generation
% % [N, L, K ] = sh4d_indices_gen(N_max,L_max);
% % if verbose,disp(['Ideal basis size: ' num2str(length(N))]);end
% % basis_size = length(L)-mod(length(L),4);
% % N = (N(1:basis_size));
% % L = (L(1:basis_size));
% % K = (K(1:basis_size));

N = DNLK.N;
L = DNLK.L;
K = DNLK.K;
D = DNLK.D;
thresh = 1e-7;
remove_vec = find(D.^2<thresh);
D(remove_vec) = [];
N(remove_vec) = [];
L(remove_vec) = [];
K(remove_vec) = [];

if verbose,disp(['basis size: ' num2str(length(N))]);end

M = length(I(:));
s = round(size_limit /M/4); % number of basis vectors that fit into one task with this I and size_limit   %       totalsize = length(I)*s * 4;    % 4 bytes for single precision
remain = length(N); % start out with all basis vectors remaining
counter = 0;
pos  = 1;
inp1 = {};
inp_vec = {};   % cell array of cell arrays of inputs
D_vec = {};
while remain>0,
    counter = counter +1;
    %% distribute these parts of the basis matrix as tasks
    if length(N(pos:end))>=s
        vec = pos : pos+s-1;
        inp1{1} = N(vec);inp1{2} = L(vec);inp1{3} = K(vec);inp1{4} = p(:)';inp1{5} = t(:)';inp1{6} = r(:)';inp1{7} = tau;
        D_temp = D(vec);
        pos = pos + s;
        remain = remain-s;
    else
        if (pos+length(N(pos:end))-1)>pos,
            vec = pos : pos+length(N(pos:end))-1;
            inp1{1} = N(vec);inp1{2} = L(vec);inp1{3} = K(vec);inp1{4} = p(:)';inp1{5} = t(:)';inp1{6} = r(:)';inp1{7} = tau;
            pos = pos + s;
            remain = remain-length(vec);
            D_temp = D(vec);
        end
    end
    inp_vec{counter} = inp1;
    D_vec{counter} = D_temp;
end

if verbose,
str = sprintf(...
    '# basis vectors/task for basis matrix of singles: %d \n Total # of tasks: %d \n Dimension of basis matrix chunck:  %d x %d = %d',...
    s,size(inp_vec,2),M, s, s*M); disp(str);
end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
N = [];L = [];K = [];
for ix = 1:size(inp_vec,2),
    inp = inp_vec{ix};
    N = [N; inp{1}];L = [L; inp{2}];K = [K; inp{3}];
    disp(['Task ' num2str(ix) ' : ' num2str(length(inp{1})) ' basis vectors']);
end
sched = findResource('scheduler', 'type', 'local');
remaining_tasks = length(inp_vec);
pos = 0;
counter = 0;
residual = I(:);
res_vec = [];
f = 0;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% START SIRF ITERATIONS %%%%%%%%%%%%%%%%%%%%%%
Nproc = 4;
while remaining_tasks>0
    counter = counter + 1;
    D = [];
    if verbose,disp(['# of remaining tasks ' num2str(remaining_tasks)]);end;
    j = createJob(sched);
    if remaining_tasks>=Nproc,
        for ix = 1:Nproc,
            pos = pos + 1;
            warning off;createTask(j, @sh4d_basis_gen_vec, 1, inp_vec{pos});warning on;
            D = [D; D_vec{pos}];
        end
        remaining_tasks = remaining_tasks-Nproc;
    else
        for ix = 1:remaining_tasks,
            pos = pos + 1;
            warning off;createTask(j, @sh4d_basis_gen_vec, 1, inp_vec{pos});warning on;
            D = [D; D_vec{pos}];
        end
        remaining_tasks = 0;
    end
    if verbose, disp(['Submitting task batch '  num2str(counter) ' (using ' num2str(Nproc) ' tasks/batch)']);end
    submit(j);waitForState(j, 'finished'); % Execute 4 consecutive tasks untill all tasks are done.
    if verbose, disp('......... finished!');end
    %%%% display errors if any
    errmsgs = get(j.Tasks, {'ErrorMessage'});
    nonempty = ~cellfun(@isempty, errmsgs);
    celldisp(errmsgs(nonempty));
    %%%
    results = getAllOutputArguments(j)';
    A = cell2mat(results);
    clear results;destroy(j);
    if verbose, disp('basis matrix size');disp(size(A));end;
% %     if ~any(size(A)~=[length(p) 4*s])==0,
% %         error('Basis matrix dimensions inconsistency');
% %     end
    
    I(:)= I(:) + A*D(:);
  
    if verbose, 
        warning off;
        Isyn = I(pad_vec(1):end-pad_vec(1)-1, pad_vec(2):end-pad_vec(2)-1, pad_vec(3):end-pad_vec(3)-1);
        %% display
        kk_montage(mat2gray(Isyn));
        warning on;
        drawnow;
    end
end

warning off;
I = I(pad_vec(1):end-pad_vec(1)-1, pad_vec(2):end-pad_vec(2)-1, pad_vec(3):end-pad_vec(3)-1);
%% display
kk_montage(mat2gray(Isyn));
warning on;



